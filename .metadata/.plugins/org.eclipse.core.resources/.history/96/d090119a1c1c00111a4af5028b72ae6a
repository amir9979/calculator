package dev.log.trace;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;

import dev.log.activity.ComponentVector;
import dev.log.activity.Matrix;

import edu.emory.mathcs.backport.java.util.Collections;

/**
 * Staccato algorithm described by Rui Abreu and Arjan J.C. van Gemund
 * for finding a minimal hitting set.
 * 
 * @author Joel van den Berg
 *
 */

public class Staccato {

	/**
	 * The matrix containing the components.
	 */
	private Matrix matrix;
	
	/**
	 * The number of components in the matrix
	 */
	private int m;
	
	/**
	 * A stop criterion for the amount of the matrix seen.
	 */
	private double lambda;
	
	/**
	 * A stop criterion for the number of minimal sets returned.
	 */
	private int l;
	
	/**
	 * The list of Ochiai coefficients for the components.
	 */
	private HashMap<String,Double> h = new HashMap<String,Double>();
	
	/**
	 * The order of the components in terms of the Ochiai coefficients.
	 */
	private ArrayList<String> r = new ArrayList<String>();
	
	/**
	 * The counts of aij as used in the calculation of the Ochiai coefficients.
	 */
	private HashMap<Object,HashMap<String,Integer>> nij = new HashMap<Object,HashMap<String,Integer>>();
	
	/**
	 * Calculate the Ochiai coefficient for this matrix.
	 * @param matrix	The matrix containing the components hits and the error vector at key -1.
	 * @throws Exception 
	 */
	
	
	public ArrayList<ArrayList<String>> calculate(Matrix matrixi, double lambdai, int li) throws Exception{
		matrix = matrixi;
		m = matrixi.getComponentCount();
		lambda = lambdai;
		l = li;
		
		/**
		 * Count conflicting sets
		 */
		int Tf = 0;
		for(Integer i : matrix.getError().getValues()) {
			Tf += i;
		}	

		r = matrix.getRank();
		
		/**
		 * Initiate empty conflict set
		 */
		ArrayList<ArrayList<String>> d = new ArrayList<ArrayList<String>>();
		
		/**
		 * Initiate the part of the matrix we have seen
		 */
		double seen = 0.0;
		
		Matrix matrix_copy = matrix.copy();
		for(ComponentVector component : matrix_copy.getComponents()) {
			if (component.getCounts().get("n11") == Tf) {
				ArrayList<String> set = new ArrayList<String>();
				set.add(component.getHeader());
				d.add(set);
				/* Strip_Component(A,j) */
				matrix.removeComponent(component.getHeader());
				r.remove(component.getHeader());
				seen += 1/m;
			}
		}
		
		System.out.println("Matrix after 5-12: " + matrix);
		
		while(!r.isEmpty() && seen <= lambda && d.size() <= l) {
			String j = r.remove(0);
			seen += 1/m;
			Staccato staccato = new Staccato();
			
			Matrix new_matrix = matrix.copy();
			new_matrix.strip(j);

			System.out.println("recursion" + new_matrix);
			ArrayList<ArrayList<String>> dprime = staccato.calculate(new_matrix, lambda, l);
			System.out.println("end recursion" + new_matrix);
			
			while(!dprime.isEmpty()) {
				ArrayList<String> jprime = dprime.remove(0);
				jprime.add(j);
				if(isNotSubsumed(d,jprime))
					d.add(jprime);
			}
		}
		
		return d;
	}

	private boolean isSubsumed(ArrayList<ArrayList<String>> d,
			ArrayList<String> jprime) {
		
		ArrayList<String> jprimeCopy = new ArrayList<String>(jprime);
		Collections.copy(jprimeCopy, jprime);
		Collections.sort(jprimeCopy);
		
		for(ArrayList<String> item : d) {
			ArrayList<String> dCopy = new ArrayList<String>(item);
			Collections.copy(dCopy, item);
			Collections.sort(dCopy);
			if()			
		}

		return true;
	}

}
